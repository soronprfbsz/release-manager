# ========================================
# GitLab CI/CD Pipeline Configuration
# ========================================

default:
  image: docker:24-cli

variables:
  # Docker 이미지 설정
  DOCKER_IMAGE_NAME: "ts/release-manager"
  DOCKER_IMAGE_TAG: "latest"

  # Harbor Registry 설정 (선택적)
  HARBOR_REGISTRY: "10.230.1.17"
  HARBOR_PROJECT: "release-manager"
  HARBOR_IMAGE_NAME: "${HARBOR_REGISTRY}/${HARBOR_PROJECT}/release-manager-api"

  # Gradle 설정
  GRADLE_OPTS: "-Dorg.gradle.daemon=false"
  GRADLE_USER_HOME: $CI_PROJECT_DIR/.gradle

stages:
  - build
  - test
  - docker-build
  - harbor-push
  - deploy

# ========================================
# 빌드 단계
# ========================================
build:
  stage: build
  image: gradle:8.5-jdk17-alpine
  tags:
    - 17-runner
  only:
    - main
  cache:
    key: ${CI_COMMIT_REF_SLUG}
    paths:
      - .gradle/
      - build/
  script:
    - echo "프로젝트 빌드 시작..."
    - gradle clean build -x test --no-daemon
    - echo "빌드 완료"
  artifacts:
    paths:
      - build/libs/*.jar
    expire_in: 1 hour

# ========================================
# 테스트 단계 (수동 실행)
# ========================================
test:
  stage: test
  image: gradle:8.5-jdk17-alpine
  tags:
    - 17-runner
  only:
    - main
  cache:
    key: ${CI_COMMIT_REF_SLUG}
    paths:
      - .gradle/
  script:
    - echo "테스트 실행 중..."
    - gradle test --no-daemon
    - echo "테스트 완료"
  artifacts:
    when: always
    reports:
      junit: build/test-results/test/TEST-*.xml
    paths:
      - build/test-results/
      - build/reports/
    expire_in: 1 weeks
  coverage: '/Total.*?([0-9]{1,3})%/'
  when: manual  # 수동 실행 (필요시에만)

# ========================================
# Docker 이미지 빌드 단계 (로컬)
# ========================================
docker-build:
  stage: docker-build
  tags:
    - 17-runner
  only:
    - main
  dependencies:
    - build
  script:
    - echo "Docker 이미지 빌드 시작..."
    - docker build -f docker/Dockerfile -t ${DOCKER_IMAGE_NAME}:${DOCKER_IMAGE_TAG} . --progress=plain --force-rm
    - 'echo "이미지 빌드 완료: ${DOCKER_IMAGE_NAME}:${DOCKER_IMAGE_TAG}"'
    - docker images | grep ${DOCKER_IMAGE_NAME}

# ========================================
# Harbor Push 단계 (선택적)
# ========================================
# Harbor에 이미지를 등록하려면 이 Job을 수동으로 실행하세요
harbor-push:
  stage: harbor-push
  tags:
    - 17-runner
  only:
    - main
  dependencies:
    - docker-build
  before_script:
    - echo "Harbor 로그인 중..."
    - echo "$HARBOR_PASSWORD" | docker login $HARBOR_REGISTRY -u $HARBOR_USERNAME --password-stdin
  script:
    - echo "로컬 이미지를 Harbor 형식으로 태깅..."
    - docker tag ${DOCKER_IMAGE_NAME}:${DOCKER_IMAGE_TAG} ${HARBOR_IMAGE_NAME}:${CI_COMMIT_SHORT_SHA}
    - docker tag ${DOCKER_IMAGE_NAME}:${DOCKER_IMAGE_TAG} ${HARBOR_IMAGE_NAME}:latest
    - echo "Harbor에 이미지 Push 중..."
    - docker push ${HARBOR_IMAGE_NAME}:${CI_COMMIT_SHORT_SHA}
    - docker push ${HARBOR_IMAGE_NAME}:latest
    - echo "이미지가 Harbor에 성공적으로 등록되었습니다!"
    - echo "  - ${HARBOR_IMAGE_NAME}:${CI_COMMIT_SHORT_SHA}"
    - echo "  - ${HARBOR_IMAGE_NAME}:latest"
  after_script:
    - docker logout $HARBOR_REGISTRY || true
  when: manual  # 수동 실행 (필요시에만)

# ========================================
# 배포 단계 (GitLab Runner 호스트)
# ========================================
deploy:
  stage: deploy
  tags:
    - 17-runner
  only:
    - main
  dependencies:
    - docker-build
  before_script:
    - |
      echo "=== 필수 도구 설치 중 ==="
      apk add --no-cache curl 2>/dev/null || apt-get update && apt-get install -y curl 2>/dev/null || yum install -y curl 2>/dev/null || true
      command -v curl && echo "✓ curl 설치됨" || echo "✗ curl 설치 실패"
    - |
      echo "=== Gitlab Variables로 .env 파일 생성 중 ==="
      env | grep -vE '^(CI=|CI_|GITLAB_|FF_|RUNNER_|DOCKER_|DIND_|PATH=|HOME=|HOSTNAME=|PWD=|OLDPWD=|SHELL=|SHLVL=|USER=|_=|LANG=|LC_|TERM=|DEBIAN_|GRADLE_)' > .env

      # Docker 이미지 정보 추가
      echo "DOCKER_IMAGE=${DOCKER_IMAGE_NAME}:${DOCKER_IMAGE_TAG}" >> .env

      cat .env
      cp .env docker/.env
    - |
      echo "=== Docker 네트워크 확인 ==="
      docker network ls | grep -q network-ts && echo "✓ network-ts 존재" || (docker network create network-ts && echo "✓ network-ts 생성")
  script:
    - |
      echo "=== 배포 시작 ==="
      docker-compose -f docker/docker-compose.yml rm -f mariadb redis app || true
    - |
      echo "=== MariaDB 시작 ==="
      if docker ps --format '{{.Names}}' | grep -q '^rm-mariadb$'; then
        echo "✓ MariaDB 실행 중"
      elif docker ps -a --format '{{.Names}}' | grep -q '^rm-mariadb$'; then
        docker start rm-mariadb && echo "✓ MariaDB 재시작됨"
      else
        docker-compose -f docker/docker-compose.yml up -d mariadb && echo "✓ MariaDB 생성됨"
      fi
    - |
      echo "=== Redis 시작 ==="
      if docker ps --format '{{.Names}}' | grep -q '^rm-redis$'; then
        echo "✓ Redis 실행 중"
      elif docker ps -a --format '{{.Names}}' | grep -q '^rm-redis$'; then
        docker start rm-mariadb && echo "✓ Redis 재시작됨"
      else
        docker-compose -f docker/docker-compose.yml up -d redis && echo "✓ Redis 생성됨"
      fi
    - |
      echo "=== MariaDB 헬스체크 ==="
      max_attempts=30
      attempt=0
      until docker exec rm-mariadb healthcheck.sh --connect --innodb_initialized || [ $attempt -eq $max_attempts ]; do
        attempt=$((attempt+1))
        sleep 2
      done
      if [ $attempt -eq $max_attempts ]; then
        echo "✗ MariaDB 헬스체크 실패"
        docker logs --tail 20 rm-mariadb
        exit 1
      fi
      echo "✓ MariaDB 준비 완료"
    - |
      echo "=== Redis 헬스체크 ==="
      max_attempts=30
      attempt=0
      until docker exec rm-redis redis-cli ping || [ $attempt -eq $max_attempts ]; do
        attempt=$((attempt+1))
        sleep 2
      done
      if [ $attempt -eq $max_attempts ]; then
        echo "✗ Redis 헬스체크 실패"
        docker logs --tail 20 rm-redis
        exit 1
      fi
      echo "✓ Redis 준비 완료"
    - |
      echo "=== 애플리케이션 배포 ==="
      docker stop ${SERVER_NAME} || true
      docker rm -f ${SERVER_NAME} || true
      docker-compose -f docker/docker-compose.yml up -d --no-deps app
      echo "✓ 컨테이너 시작됨"
      sleep 10
    - |
      echo "=== 애플리케이션 헬스체크 ==="
      max_attempts=30
      attempt=0
      until curl -sf http://${SERVER_HOST}:${SERVER_EXTERNAL_PORT}/actuator/health > /dev/null || [ $attempt -eq $max_attempts ]; do
        attempt=$((attempt+1))
        echo "  대기 중... ($attempt/$max_attempts)"
        sleep 2
      done
      if [ $attempt -eq $max_attempts ]; then
        echo "✗ 애플리케이션 헬스체크 실패"
        docker logs ${SERVER_NAME}
        exit 1
      fi
      echo "✓ 애플리케이션 준비 완료"
      echo "=== 배포 성공 ==="
  after_script:
    - echo "=== 정리 작업 ==="
    - docker images -f "dangling=true" -f "label=project=${HARBOR_PROJECT}" -q | xargs -r docker rmi -f 2>/dev/null || true
    - docker image prune -f --filter "label=project=${HARBOR_PROJECT}" --filter "dangling=true" 2>/dev/null || true
    - echo "✓ Dangling 이미지 정리 완료"
    - echo "=== 배포 상태 ==="
    - docker ps --filter "name=${SERVER_NAME}" --format "table {{.Names}}\t{{.Image}}\t{{.Status}}\t{{.Ports}}"
    - docker images --filter "reference=${DOCKER_IMAGE_NAME}" --format "table {{.Repository}}\t{{.Tag}}\t{{.ID}}\t{{.Size}}"
  environment:
    name: production
    url: http://${SERVER_HOST}:${SERVER_EXTERNAL_PORT}
